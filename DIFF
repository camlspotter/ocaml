diff --git a/.depend b/.depend
index 50b6337..84bd9db 100644
--- a/.depend
+++ b/.depend
@@ -600,8 +600,8 @@ asmcomp/selectgen.cmi : utils/tbl.cmi asmcomp/reg.cmi asmcomp/mach.cmi \
 asmcomp/selection.cmi : asmcomp/mach.cmi asmcomp/cmm.cmi
 asmcomp/spill.cmi : asmcomp/mach.cmi
 asmcomp/split.cmi : asmcomp/mach.cmi
-asmcomp/arch.cmo :
-asmcomp/arch.cmx :
+asmcomp/arch.cmo : utils/config.cmi
+asmcomp/arch.cmx : utils/config.cmx
 asmcomp/asmgen.cmo : bytecomp/translmod.cmi asmcomp/split.cmi \
     asmcomp/spill.cmi asmcomp/selection.cmi asmcomp/scheduling.cmi \
     asmcomp/reload.cmi asmcomp/reg.cmi asmcomp/proc.cmi asmcomp/printmach.cmi \
@@ -765,9 +765,9 @@ asmcomp/proc.cmx : asmcomp/reg.cmx utils/misc.cmx asmcomp/mach.cmx \
 asmcomp/reg.cmo : asmcomp/cmm.cmi asmcomp/reg.cmi
 asmcomp/reg.cmx : asmcomp/cmm.cmx asmcomp/reg.cmi
 asmcomp/reload.cmo : asmcomp/reloadgen.cmi asmcomp/reg.cmi asmcomp/mach.cmi \
-    asmcomp/cmm.cmi utils/clflags.cmi asmcomp/arch.cmo asmcomp/reload.cmi
+    asmcomp/cmm.cmi asmcomp/arch.cmo asmcomp/reload.cmi
 asmcomp/reload.cmx : asmcomp/reloadgen.cmx asmcomp/reg.cmx asmcomp/mach.cmx \
-    asmcomp/cmm.cmx utils/clflags.cmx asmcomp/arch.cmx asmcomp/reload.cmi
+    asmcomp/cmm.cmx asmcomp/arch.cmx asmcomp/reload.cmi
 asmcomp/reloadgen.cmo : asmcomp/reg.cmi utils/misc.cmi asmcomp/mach.cmi \
     asmcomp/reloadgen.cmi
 asmcomp/reloadgen.cmx : asmcomp/reg.cmx utils/misc.cmx asmcomp/mach.cmx \
@@ -789,11 +789,11 @@ asmcomp/selectgen.cmx : utils/tbl.cmx bytecomp/simplif.cmx asmcomp/reg.cmx \
     asmcomp/debuginfo.cmx asmcomp/cmm.cmx asmcomp/arch.cmx \
     asmcomp/selectgen.cmi
 asmcomp/selection.cmo : asmcomp/selectgen.cmi asmcomp/proc.cmi \
-    utils/misc.cmi asmcomp/mach.cmi asmcomp/cmm.cmi utils/clflags.cmi \
-    asmcomp/arch.cmo asmcomp/selection.cmi
+    utils/misc.cmi asmcomp/mach.cmi asmcomp/cmm.cmi asmcomp/arch.cmo \
+    asmcomp/selection.cmi
 asmcomp/selection.cmx : asmcomp/selectgen.cmx asmcomp/proc.cmx \
-    utils/misc.cmx asmcomp/mach.cmx asmcomp/cmm.cmx utils/clflags.cmx \
-    asmcomp/arch.cmx asmcomp/selection.cmi
+    utils/misc.cmx asmcomp/mach.cmx asmcomp/cmm.cmx asmcomp/arch.cmx \
+    asmcomp/selection.cmi
 asmcomp/spill.cmo : asmcomp/reg.cmi asmcomp/proc.cmi utils/misc.cmi \
     asmcomp/mach.cmi asmcomp/spill.cmi
 asmcomp/spill.cmx : asmcomp/reg.cmx asmcomp/proc.cmx utils/misc.cmx \
@@ -816,21 +816,21 @@ driver/compenv.cmo : utils/warnings.cmi utils/misc.cmi parsing/location.cmi \
     utils/config.cmi utils/clflags.cmi driver/compenv.cmi
 driver/compenv.cmx : utils/warnings.cmx utils/misc.cmx parsing/location.cmx \
     utils/config.cmx utils/clflags.cmx driver/compenv.cmi
-driver/compile.cmo : utils/warnings.cmi typing/typemod.cmi \
-    typing/typedtree.cmi typing/typecore.cmi bytecomp/translmod.cmi \
-    typing/stypes.cmi bytecomp/simplif.cmi typing/printtyped.cmi \
-    typing/printtyp.cmi bytecomp/printlambda.cmi bytecomp/printinstr.cmi \
-    parsing/printast.cmi parsing/pprintast.cmi driver/pparse.cmi \
-    parsing/parse.cmi utils/misc.cmi parsing/location.cmi \
+driver/compile.cmo : utils/warnings.cmi tools/untypeast.cmi \
+    typing/typemod.cmi typing/typedtree.cmi typing/typecore.cmi \
+    bytecomp/translmod.cmi typing/stypes.cmi bytecomp/simplif.cmi \
+    typing/printtyped.cmi typing/printtyp.cmi bytecomp/printlambda.cmi \
+    bytecomp/printinstr.cmi parsing/printast.cmi parsing/pprintast.cmi \
+    driver/pparse.cmi parsing/parse.cmi utils/misc.cmi parsing/location.cmi \
     typing/includemod.cmi typing/env.cmi bytecomp/emitcode.cmi \
     utils/config.cmi driver/compmisc.cmi driver/compenv.cmi utils/clflags.cmi \
     utils/ccomp.cmi bytecomp/bytegen.cmi driver/compile.cmi
-driver/compile.cmx : utils/warnings.cmx typing/typemod.cmx \
-    typing/typedtree.cmx typing/typecore.cmx bytecomp/translmod.cmx \
-    typing/stypes.cmx bytecomp/simplif.cmx typing/printtyped.cmx \
-    typing/printtyp.cmx bytecomp/printlambda.cmx bytecomp/printinstr.cmx \
-    parsing/printast.cmx parsing/pprintast.cmx driver/pparse.cmx \
-    parsing/parse.cmx utils/misc.cmx parsing/location.cmx \
+driver/compile.cmx : utils/warnings.cmx tools/untypeast.cmx \
+    typing/typemod.cmx typing/typedtree.cmx typing/typecore.cmx \
+    bytecomp/translmod.cmx typing/stypes.cmx bytecomp/simplif.cmx \
+    typing/printtyped.cmx typing/printtyp.cmx bytecomp/printlambda.cmx \
+    bytecomp/printinstr.cmx parsing/printast.cmx parsing/pprintast.cmx \
+    driver/pparse.cmx parsing/parse.cmx utils/misc.cmx parsing/location.cmx \
     typing/includemod.cmx typing/env.cmx bytecomp/emitcode.cmx \
     utils/config.cmx driver/compmisc.cmx driver/compenv.cmx utils/clflags.cmx \
     utils/ccomp.cmx bytecomp/bytegen.cmx driver/compile.cmi
@@ -1042,3 +1042,94 @@ toplevel/trace.cmx : typing/types.cmx toplevel/toploop.cmx \
     typing/printtyp.cmx typing/predef.cmx typing/path.cmx utils/misc.cmx \
     bytecomp/meta.cmx parsing/longident.cmx typing/ctype.cmx \
     toplevel/trace.cmi
+tools/depend.cmi : parsing/parsetree.cmi
+tools/profiling.cmi :
+tools/tast_iter.cmi : typing/typedtree.cmi parsing/asttypes.cmi
+tools/untypeast.cmi : typing/typedtree.cmi typing/path.cmi \
+    parsing/parsetree.cmi parsing/longident.cmi
+tools/addlabels.cmo : parsing/parsetree.cmi parsing/parse.cmi \
+    parsing/longident.cmi parsing/location.cmi parsing/asttypes.cmi
+tools/addlabels.cmx : parsing/parsetree.cmi parsing/parse.cmx \
+    parsing/longident.cmx parsing/location.cmx parsing/asttypes.cmi
+tools/cmt2annot.cmo : tools/untypeast.cmi typing/types.cmi \
+    typing/typedtree.cmi tools/tast_iter.cmi typing/stypes.cmi \
+    parsing/pprintast.cmi typing/path.cmi typing/oprint.cmi \
+    parsing/location.cmi typing/ident.cmi typing/envaux.cmi typing/env.cmi \
+    utils/config.cmi typing/cmt_format.cmi parsing/asttypes.cmi \
+    typing/annot.cmi
+tools/cmt2annot.cmx : tools/untypeast.cmx typing/types.cmx \
+    typing/typedtree.cmx tools/tast_iter.cmx typing/stypes.cmx \
+    parsing/pprintast.cmx typing/path.cmx typing/oprint.cmx \
+    parsing/location.cmx typing/ident.cmx typing/envaux.cmx typing/env.cmx \
+    utils/config.cmx typing/cmt_format.cmx parsing/asttypes.cmi \
+    typing/annot.cmi
+tools/cvt_emit.cmo :
+tools/cvt_emit.cmx :
+tools/depend.cmo : parsing/parsetree.cmi utils/misc.cmi \
+    parsing/longident.cmi parsing/location.cmi parsing/asttypes.cmi \
+    tools/depend.cmi
+tools/depend.cmx : parsing/parsetree.cmi utils/misc.cmx \
+    parsing/longident.cmx parsing/location.cmx parsing/asttypes.cmi \
+    tools/depend.cmi
+tools/dumpobj.cmo : utils/tbl.cmi bytecomp/opcodes.cmo utils/misc.cmi \
+    parsing/location.cmi bytecomp/lambda.cmi bytecomp/instruct.cmi \
+    typing/ident.cmi utils/config.cmi bytecomp/cmo_format.cmi \
+    bytecomp/bytesections.cmi parsing/asttypes.cmi
+tools/dumpobj.cmx : utils/tbl.cmx bytecomp/opcodes.cmx utils/misc.cmx \
+    parsing/location.cmx bytecomp/lambda.cmx bytecomp/instruct.cmx \
+    typing/ident.cmx utils/config.cmx bytecomp/cmo_format.cmi \
+    bytecomp/bytesections.cmx parsing/asttypes.cmi
+tools/eqparsetree.cmo : parsing/parsetree.cmi parsing/longident.cmi \
+    parsing/location.cmi parsing/asttypes.cmi
+tools/eqparsetree.cmx : parsing/parsetree.cmi parsing/longident.cmx \
+    parsing/location.cmx parsing/asttypes.cmi
+tools/myocamlbuild_config.cmo :
+tools/myocamlbuild_config.cmx :
+tools/objinfo.cmo : utils/misc.cmi utils/config.cmi asmcomp/cmx_format.cmi \
+    bytecomp/cmo_format.cmi typing/cmi_format.cmi asmcomp/clambda.cmi \
+    bytecomp/bytesections.cmi
+tools/objinfo.cmx : utils/misc.cmx utils/config.cmx asmcomp/cmx_format.cmi \
+    bytecomp/cmo_format.cmi typing/cmi_format.cmx asmcomp/clambda.cmx \
+    bytecomp/bytesections.cmx
+tools/ocaml299to3.cmo :
+tools/ocaml299to3.cmx :
+tools/ocamlcp.cmo : driver/main_args.cmi
+tools/ocamlcp.cmx : driver/main_args.cmx
+tools/ocamldep.cmo : parsing/syntaxerr.cmi driver/pparse.cmi \
+    parsing/parsetree.cmi parsing/parse.cmi utils/misc.cmi \
+    parsing/location.cmi parsing/lexer.cmi tools/depend.cmi utils/config.cmi \
+    driver/compenv.cmi utils/clflags.cmi
+tools/ocamldep.cmx : parsing/syntaxerr.cmx driver/pparse.cmx \
+    parsing/parsetree.cmi parsing/parse.cmx utils/misc.cmx \
+    parsing/location.cmx parsing/lexer.cmx tools/depend.cmx utils/config.cmx \
+    driver/compenv.cmx utils/clflags.cmx
+tools/ocamlmktop.cmo : utils/ccomp.cmi
+tools/ocamlmktop.cmx : utils/ccomp.cmx
+tools/ocamloptp.cmo : driver/main_args.cmi
+tools/ocamloptp.cmx : driver/main_args.cmx
+tools/ocamlprof.cmo : utils/warnings.cmi parsing/syntaxerr.cmi \
+    parsing/parsetree.cmi parsing/parse.cmi parsing/location.cmi \
+    parsing/lexer.cmi
+tools/ocamlprof.cmx : utils/warnings.cmx parsing/syntaxerr.cmx \
+    parsing/parsetree.cmi parsing/parse.cmx parsing/location.cmx \
+    parsing/lexer.cmx
+tools/primreq.cmo : utils/config.cmi bytecomp/cmo_format.cmi
+tools/primreq.cmx : utils/config.cmx bytecomp/cmo_format.cmi
+tools/profiling.cmo : tools/profiling.cmi
+tools/profiling.cmx : tools/profiling.cmi
+tools/read_cmt.cmo : typing/cmt_format.cmi tools/cmt2annot.cmo \
+    utils/clflags.cmi
+tools/read_cmt.cmx : typing/cmt_format.cmx tools/cmt2annot.cmx \
+    utils/clflags.cmx
+tools/scrapelabels.cmo :
+tools/scrapelabels.cmx :
+tools/tast_iter.cmo : typing/typedtree.cmi parsing/asttypes.cmi \
+    tools/tast_iter.cmi
+tools/tast_iter.cmx : typing/typedtree.cmx parsing/asttypes.cmi \
+    tools/tast_iter.cmi
+tools/untypeast.cmo : typing/typedtree.cmi typing/path.cmi \
+    parsing/parsetree.cmi parsing/longident.cmi typing/ident.cmi \
+    parsing/asttypes.cmi tools/untypeast.cmi
+tools/untypeast.cmx : typing/typedtree.cmx typing/path.cmx \
+    parsing/parsetree.cmi parsing/longident.cmx typing/ident.cmx \
+    parsing/asttypes.cmi tools/untypeast.cmi
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..bc87c14
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,13 @@
+*.o
+*.cm*
+*.bak
+*.opt
+*.a
+*.so
+*~
+*.annot
+\#*
+.#*
+*.ml1
+*.ml2
+
diff --git a/Changes b/Changes
index 9c8093a..8d7b20c 100644
--- a/Changes
+++ b/Changes
@@ -374,8 +374,7 @@ Bug fixes:
   (Jacques Garrigue, report by Leo P. White)
 - PR#6164: segmentation fault on Num.power_num of 0/1
   (Fabrice Le Fessant, report by Johannes Kanig)
-- PR#6210: Camlp4 location error
-  (Hongbo Zhang, report by Jun Furuse)
+
 Feature wishes:
 - PR#5181: Merge common floating point constants in ocamlopt
   (Benedikt Meurer)
diff --git a/Makefile b/Makefile
index 10c80d2..322d5e1 100644
--- a/Makefile
+++ b/Makefile
@@ -33,7 +33,7 @@ CAMLP4OUT=$(CAMLP4:=out)
 CAMLP4OPT=$(CAMLP4:=opt)
 
 INCLUDES=-I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver \
-	 -I toplevel
+	 -I toplevel -I tools
 
 UTILS=utils/misc.cmo utils/tbl.cmo utils/config.cmo \
   utils/clflags.cmo utils/terminfo.cmo utils/ccomp.cmo utils/warnings.cmo \
@@ -73,7 +73,7 @@ BYTECOMP=bytecomp/meta.cmo bytecomp/instruct.cmo bytecomp/bytegen.cmo \
   bytecomp/printinstr.cmo bytecomp/opcodes.cmo bytecomp/emitcode.cmo \
   bytecomp/bytesections.cmo bytecomp/dll.cmo bytecomp/symtable.cmo \
   bytecomp/bytelink.cmo bytecomp/bytelibrarian.cmo bytecomp/bytepackager.cmo \
-  driver/errors.cmo driver/compile.cmo
+  driver/errors.cmo tools/untypeast.cmo driver/compile.cmo
 
 ASMCOMP=asmcomp/arch.cmo asmcomp/debuginfo.cmo \
   asmcomp/cmm.cmo asmcomp/printcmm.cmo \
@@ -802,7 +802,7 @@ partialclean::
 	rm -f *~
 
 depend: beforedepend
-	(for d in utils parsing typing bytecomp asmcomp driver toplevel; \
+	(for d in utils parsing typing bytecomp asmcomp driver toplevel tools; \
 	 do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
 	 done) > .depend
 
diff --git a/boot/ocamlc b/boot/ocamlc
index 72164e9..1d75b89 100755
Binary files a/boot/ocamlc and b/boot/ocamlc differ
diff --git a/boot/ocamldep b/boot/ocamldep
index cdfd1dc..2c99240 100755
Binary files a/boot/ocamldep and b/boot/ocamldep differ
diff --git a/boot/ocamllex b/boot/ocamllex
index 31beb41..ad5b625 100755
Binary files a/boot/ocamllex and b/boot/ocamllex differ
diff --git a/camlp4/Camlp4/Sig.ml b/camlp4/Camlp4/Sig.ml
index 02c1ef1..bae3da5 100644
--- a/camlp4/Camlp4/Sig.ml
+++ b/camlp4/Camlp4/Sig.ml
@@ -109,9 +109,7 @@ module type Loc = sig
   (** [merge loc1 loc2] Return a location that starts at [loc1] and end at
       [loc2]. *)
   value merge : t -> t -> t;
-  (** [smart_merge loc1 loc2] Try to return a location that covers both [loc1] and [loc2]*)
-    
-  value smart_merge : t -> t -> t ;  
+
   (** The stop pos becomes equal to the start pos. *)
   value join : t -> t;
 
diff --git a/camlp4/Camlp4/Struct/Loc.ml b/camlp4/Camlp4/Struct/Loc.ml
index 97f795f..2fd2c91 100644
--- a/camlp4/Camlp4/Struct/Loc.ml
+++ b/camlp4/Camlp4/Struct/Loc.ml
@@ -98,33 +98,6 @@ value dump f x =
 
 value start_pos = { line = 1 ; bol = 0 ; off = 0 };
 
-value min_pos (x:pos) (y:pos) =
-  if x.off < y.off
-  then x
-  else y;
-value max_pos (x:pos) (y:pos) =
-  if x.off > y.off
-  then x
-  else y;
-
-value smart_merge (a:t) (b:t) =
-  if a == b then a
-  else
-    match (a,b) with
-    [ ({ghost=False;start=a0;stop=a1;file_name = f},
-       {ghost=False;start=b0;stop=b1;_}) ->
-        {ghost = False;
-         start = min_pos a0 b0;
-         stop = max_pos a1 b1;
-         file_name = f
-       }
-    | ({ghost = True;_},{ghost=True;_})
-    | ({ghost = True;_},_) -> {(a) with stop = b.stop }
-    | ({ghost = _;_},{ghost = True;_}) ->
-        {(b) with start = a.start }
-    ]
-;
-      
 value ghost =
   { file_name = "ghost-location";
     start     = start_pos;
diff --git a/camlp4/Camlp4Parsers/Camlp4OCamlParser.ml b/camlp4/Camlp4Parsers/Camlp4OCamlParser.ml
index 50318a2..940e2a1 100644
--- a/camlp4/Camlp4Parsers/Camlp4OCamlParser.ml
+++ b/camlp4/Camlp4Parsers/Camlp4OCamlParser.ml
@@ -533,18 +533,8 @@ module Make (Syntax : Sig.Camlp4Syntax) = struct
     meth_list:
       [ [ m = meth_decl -> (m, <:row_var_flag<>>) ] ];
     comma_ctyp_app:
-      [ [ t1 = ctyp; ","; t2 = SELF ->
-        fun acc ->
-          let loc1 = Ast.loc_of_ctyp t1 in
-          let loc2 = Ast.loc_of_ctyp acc in
-          let _loc = Loc.smart_merge loc1 loc2 in
-          t2 <:ctyp< $acc$ $t1$ >>
-        | t = ctyp ->
-            fun acc ->
-              let loc1 = Ast.loc_of_ctyp t in
-              let loc2 = Ast.loc_of_ctyp acc in
-              let _loc = Loc.smart_merge loc1 loc2 in
-              <:ctyp< $acc$ $t$ >>
+      [ [ t1 = ctyp; ","; t2 = SELF -> fun acc -> t2 <:ctyp< $acc$ $t1$ >>
+        | t = ctyp -> fun acc -> <:ctyp< $acc$ $t$ >>
       ] ]
     ;
     star_ctyp:
diff --git a/driver/compile.ml b/driver/compile.ml
index 2e5b405..4a2ddfa 100644
--- a/driver/compile.ml
+++ b/driver/compile.ml
@@ -34,16 +34,54 @@ let interface ppf sourcefile outputprefix =
       Pparse.file ppf inputfile Parse.interface ast_intf_magic_number in
     if !Clflags.dump_parsetree then fprintf ppf "%a@." Printast.interface ast;
     if !Clflags.dump_source then fprintf ppf "%a@." Pprintast.signature ast;
-    let tsg = Typemod.transl_signature initial_env ast in
-    if !Clflags.dump_typedtree then fprintf ppf "%a@." Printtyped.interface tsg;
-    let sg = tsg.sig_type in
-    if !Clflags.print_types then
-      Printtyp.wrap_printing_env initial_env (fun () ->
-        fprintf std_formatter "%a@."
-          Printtyp.signature (Typemod.simplify_signature sg));
-    ignore (Includemod.signatures initial_env sg sg);
-    Typecore.force_delayed_checks ();
-    Warnings.check_fatal ();
+
+    (* Save the parsed result as xxx.mli1 *)
+    let mli1file = outputprefix ^ ".mli1" in
+    let oc1 = open_out_bin mli1file in
+    let ppf = Format.formatter_of_out_channel oc1 in
+    Format.fprintf ppf "%a@." Pprintast.signature ast;
+    close_out oc1;
+
+    let do_type ast = 
+      let tsg = Typemod.transl_signature initial_env ast in
+      if !Clflags.dump_typedtree then fprintf ppf "%a@." Printtyped.interface tsg;
+      let sg = tsg.sig_type in
+      if !Clflags.print_types then
+        Printtyp.wrap_printing_env initial_env (fun () ->
+          fprintf std_formatter "%a@."
+            Printtyp.signature (Typemod.simplify_signature sg));
+      ignore (Includemod.signatures initial_env sg sg);
+      Typecore.force_delayed_checks ();
+      Warnings.check_fatal ();
+      tsg, sg
+    in
+
+    let tsg, sg = do_type ast in
+
+    (* Untype then save it as xxx.mli2 *)
+    let ast = Untypeast.untype_signature tsg in
+    let mli2file = outputprefix ^ ".mli2" in
+    let oc2 = open_out_bin mli2file in
+    let ppf = Format.formatter_of_out_channel oc2 in
+    Format.fprintf ppf "%a@." Pprintast.signature ast;
+    close_out oc2;
+
+    (* Retype!
+
+       Beware! We must reset the state of typing, 
+       or anything strange could happen!
+           
+       I am not sure all the followings are required but at least
+       they are done at the beginning of implementation, so it should be
+       ok.
+    *)
+    Location.input_name := sourcefile;
+    Compmisc.init_path false;
+    Env.set_unit_name modulename;
+    let initial_env = Compmisc.initial_env () in
+
+    let tsg, sg = do_type ast in
+    
     if not !Clflags.print_types then begin
       let sg = Env.save_signature sg modulename (outputprefix ^ ".cmi") in
       Typemod.save_signature modulename tsg outputprefix sourcefile
@@ -89,13 +127,50 @@ let implementation ppf sourcefile outputprefix =
   end else begin
     let objfile = outputprefix ^ ".cmo" in
     let oc = open_out_bin objfile in
+
     try
       Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number
       ++ print_if ppf Clflags.dump_parsetree Printast.implementation
-      ++ print_if ppf Clflags.dump_source Pprintast.structure
+      (* ++ print_if ppf Clflags.dump_source Pprintast.structure *)
+      ++ (fun ptree -> 
+        (* Save the parsed result as xxx.ml1 *)
+        let ml1file = outputprefix ^ ".ml1" in
+        let oc1 = open_out_bin ml1file in
+        let ppf = Format.formatter_of_out_channel oc1 in
+        Format.fprintf ppf "%a@." Pprintast.structure ptree; 
+        close_out oc1;
+        ptree
+      )
       ++ Typemod.type_implementation sourcefile outputprefix modulename env
       ++ print_if ppf Clflags.dump_typedtree
                   Printtyped.implementation_with_coercion
+
+      ++ (fun (str, _) -> 
+        (* Untype then save it as xxx.ml2 *)
+        let ptree =  Untypeast.untype_structure str in
+        let ml2file = outputprefix ^ ".ml2" in
+        let oc2 = open_out_bin ml2file in
+        let ppf = Format.formatter_of_out_channel oc2 in
+        Format.fprintf ppf "%a@." Pprintast.structure ptree; 
+        close_out oc2;
+        ptree)
+
+      ++ ( fun ptree -> 
+        (* Retype!
+
+           Beware! We must reset the state of typing, 
+           or anything strange could happen!
+           
+           I am not sure all the followings are required but at least
+           they are done at the beginning of implementation, so it should be
+           ok.
+        *)
+        Location.input_name := sourcefile;
+        Compmisc.init_path false;
+        Env.set_unit_name modulename;
+        let env = Compmisc.initial_env () in
+        Typemod.type_implementation sourcefile outputprefix modulename env ptree)
+
       ++ Translmod.transl_implementation modulename
       ++ print_if ppf Clflags.dump_rawlambda Printlambda.lambda
       ++ Simplif.simplify_lambda
diff --git a/parsing/pprintast.ml b/parsing/pprintast.ml
index 0965ca6..a172ac5 100644
--- a/parsing/pprintast.ml
+++ b/parsing/pprintast.ml
@@ -195,7 +195,8 @@ class printer  ()= object(self:'self)
   (* trailing space added *)
   method rec_flag f = function
     | Nonrecursive -> ()
-    | Recursive | Default -> pp f "rec "
+    | Default -> pp f "(* default *) "
+    | Recursive -> pp f "rec "
   method direction_flag f = function
     | Upto -> pp f "to@ "
     | Downto -> pp f "downto@ "
@@ -625,8 +626,10 @@ class printer  ()= object(self:'self)
         pp f "@[<2>assert@;false@]" ;
     | Pexp_lazy (e) ->
         pp f "@[<hov2>lazy@ %a@]" self#simple_expr e
-    | Pexp_poly _ ->
-        assert false
+    | Pexp_poly (e, None) ->
+        pp f "@[<hov2>!poly!@ %a@]" self#simple_expr e
+    | Pexp_poly (e, Some ct) ->
+        pp f "@[<hov2>(!poly!@ %a@ : %a)@]" self#simple_expr e self#core_type ct
     | Pexp_open (ovf, lid, e) ->
         pp f "@[<2>let open%s %a in@;%a@]" (override ovf) self#longident_loc lid
           self#expression  e
@@ -789,7 +792,9 @@ class printer  ()= object(self:'self)
           | Pexp_poly (e,None) ->
               self#binding f ({ppat_desc=Ppat_var s;ppat_loc=Location.none} ,e)
           | _ ->
-              self#expression f e ) e
+              pp f "%s =@;%a"
+                s.txt
+                self#expression e) e
     | Pcf_constr (ct1, ct2) ->
         pp f "@[<2>constraint %a =@;%a@]" self#core_type  ct1 self#core_type  ct2
     | Pcf_init (e) ->
diff --git a/retype/.depend b/retype/.depend
new file mode 100644
index 0000000..12589bf
--- /dev/null
+++ b/retype/.depend
@@ -0,0 +1,7 @@
+untypeast.cmi :
+main.cmo : my_compile.cmo
+main.cmx : my_compile.cmx
+my_compile.cmo : untypeast.cmi
+my_compile.cmx : untypeast.cmx
+untypeast.cmo : untypeast.cmi
+untypeast.cmx : untypeast.cmi
diff --git a/retype/Makefile b/retype/Makefile
new file mode 100644
index 0000000..d96fee7
--- /dev/null
+++ b/retype/Makefile
@@ -0,0 +1,95 @@
+#######################################################################
+#                                                                     #
+#                            OCamlSpotter                             #
+#                                                                     #
+#                             Jun FURUSE                              #
+#                                                                     #
+#   Copyright 2008-2012 Jun Furuse. All rights reserved.              #
+#   This file is distributed under the terms of the GNU Library       #
+#   General Public License, with the special exception on linking     #
+#   described in file LICENSE.                                        #
+#                                                                     #
+#######################################################################
+
+
+# Various commands and dir
+##########################
+CAMLRUN= ocamlrun
+OCAMLC   = ocamlc -annot -bin-annot -w A-4-9-27-45 -warn-error A-4-9-10-27-32-33-34-39
+OCAMLOPT = ocamlopt -annot -bin-annot -w A-4-9-27-45 -warn-error A-4-9-32-33-34-39
+OCAMLDEP = ocamldep
+OCAMLLEX = ocamllex
+OCAMLYACC= ocamlyacc
+OCAMLLIB = $(LIBDIR)
+OCAMLBIN = $(BINDIR)
+
+# Compilation
+#############
+OCAMLSRCDIR=..
+
+INCLUDE_DIRS= parsing typing utils driver bytecomp
+
+INCLUDES_DEP= $(addprefix -I $(OCAMLSRCDIR)/, $(INCLUDE_DIRS)) 
+
+# Requires unix!
+COMPFLAGS= $(INCLUDES_DEP)
+
+MODULES= untypeast my_compile main
+
+OBJS=		$(addsuffix .cmo, $(MODULES))
+
+XOBJS=		$(addsuffix .cmx, $(MODULES))
+
+retype: $(OBJS) $(OCAMLSRCDIR)/compilerlibs/ocamlcommon.cma $(OCAMLSRCDIR)/compilerlibs/ocamlbytecomp.cma
+	ocamlc -o $@ -I $(OCAMLSRCDIR)/compilerlibs ocamlcommon.cma ocamlbytecomp.cma $(OBJS)
+
+clean::
+	rm -f retype
+
+main.ml: $(OCAMLSRCDIR)/driver/main.ml
+	sed -e 's/Compile\./My_compile./g' $< > $@
+
+beforedepend:: main.ml
+
+clean::
+	rm -f main.ml
+
+# generic rules :
+#################
+
+.SUFFIXES: .mll .mly .ml .mli .cmo .cmi .cmx
+
+.ml.cmo:
+	$(OCAMLC) $(OCAMLPP) $(COMPFLAGS) -c $<
+
+.mli.cmi:
+	$(OCAMLC) $(OCAMLPP) $(COMPFLAGS) -c $<
+
+.ml.cmx:
+	$(OCAMLOPT) $(OCAMLPP) $(COMPFLAGS) -c $<
+
+.mll.ml:
+	$(OCAMLLEX) $<
+
+.mly.ml:
+	$(OCAMLYACC) -v $<
+
+.mly.mli:
+	$(OCAMLYACC) -v $<
+
+beforedepend::
+
+depend: beforedepend
+	ocamldep $(INCLUDES) *.mli *.ml > .depend
+
+clean::
+	rm -f *.cm* *.annot
+
+include .depend
+
+.PHONY: bootstrap
+
+bootstrap: retype
+	cp ../boot/ocamlc ../boot/ocamlc-retype-backup
+	cp retype ../boot/ocamlc
+	(cd ..; make core)
diff --git a/retype/my_compile.ml b/retype/my_compile.ml
new file mode 100644
index 0000000..20a029d
--- /dev/null
+++ b/retype/my_compile.ml
@@ -0,0 +1,128 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                                OCaml                                *)
+(*                                                                     *)
+(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
+(*  en Automatique.  All rights reserved.  This file is distributed    *)
+(*  under the terms of the Q Public License version 1.0.               *)
+(*                                                                     *)
+(***********************************************************************)
+
+(* The batch compiler *)
+
+open Misc
+open Config
+open Format
+open Typedtree
+open Compenv
+
+(* Compile a .mli file *)
+
+let interface ppf sourcefile outputprefix =
+  Location.input_name := sourcefile;
+  Compmisc.init_path false;
+  let modulename =
+    String.capitalize(Filename.basename(chop_extension_if_any sourcefile)) in
+  check_unit_name ppf sourcefile modulename;
+  Env.set_unit_name modulename;
+  let inputfile = Pparse.preprocess sourcefile in
+  let initial_env = Compmisc.initial_env () in
+  try
+    let ast =
+      Pparse.file ppf inputfile Parse.interface ast_intf_magic_number in
+    if !Clflags.dump_parsetree then fprintf ppf "%a@." Printast.interface ast;
+    if !Clflags.dump_source then fprintf ppf "%a@." Pprintast.signature ast;
+    let tsg = Typemod.transl_signature initial_env ast in
+    if !Clflags.dump_typedtree then fprintf ppf "%a@." Printtyped.interface tsg;
+    let sg = tsg.sig_type in
+    if !Clflags.print_types then
+      Printtyp.wrap_printing_env initial_env (fun () ->
+        fprintf std_formatter "%a@."
+          Printtyp.signature (Typemod.simplify_signature sg));
+    ignore (Includemod.signatures initial_env sg sg);
+    Typecore.force_delayed_checks ();
+    Warnings.check_fatal ();
+    if not !Clflags.print_types then begin
+      let sg = Env.save_signature sg modulename (outputprefix ^ ".cmi") in
+      Typemod.save_signature modulename tsg outputprefix sourcefile
+        initial_env sg ;
+    end;
+    Pparse.remove_preprocessed inputfile
+  with e ->
+    Pparse.remove_preprocessed inputfile;
+    raise e
+
+(* Compile a .ml file *)
+
+let print_if ppf flag printer arg =
+  if !flag then fprintf ppf "%a@." printer arg;
+  arg
+
+let (++) x f = f x
+
+let implementation ppf sourcefile outputprefix =
+  Location.input_name := sourcefile;
+  Compmisc.init_path false;
+  let modulename =
+    String.capitalize(Filename.basename(chop_extension_if_any sourcefile)) in
+  check_unit_name ppf sourcefile modulename;
+  Env.set_unit_name modulename;
+  let inputfile = Pparse.preprocess sourcefile in
+  let env = Compmisc.initial_env() in
+  if !Clflags.print_types then begin
+    try ignore(
+      Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number
+      ++ print_if ppf Clflags.dump_parsetree Printast.implementation
+      ++ print_if ppf Clflags.dump_source Pprintast.structure
+      ++ Typemod.type_implementation sourcefile outputprefix modulename env
+      ++ print_if ppf Clflags.dump_typedtree
+           Printtyped.implementation_with_coercion);
+      Warnings.check_fatal ();
+      Pparse.remove_preprocessed inputfile;
+      Stypes.dump (Some (outputprefix ^ ".annot"));
+    with x ->
+      Pparse.remove_preprocessed inputfile;
+      Stypes.dump (Some (outputprefix ^ ".annot"));
+      raise x
+  end else begin
+    let objfile = outputprefix ^ ".cmo" in
+    let oc = open_out_bin objfile in
+    try
+      Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number
+      ++ print_if ppf Clflags.dump_parsetree Printast.implementation
+      (* ++ print_if ppf Clflags.dump_source Pprintast.structure *)
+      ++ (fun ptree -> Format.eprintf "%a@." Pprintast.structure ptree; ptree)
+      ++ Typemod.type_implementation sourcefile outputprefix modulename env
+      ++ print_if ppf Clflags.dump_typedtree
+                  Printtyped.implementation_with_coercion
+
+      ++ (fun (str, _) -> 
+        let ptree =  Untypeast.untype_structure str in
+        Format.eprintf "%a@." Pprintast.structure ptree;
+        ptree)
+      ++ Typemod.type_implementation sourcefile outputprefix modulename env
+
+      ++ Translmod.transl_implementation modulename
+      ++ print_if ppf Clflags.dump_rawlambda Printlambda.lambda
+      ++ Simplif.simplify_lambda
+      ++ print_if ppf Clflags.dump_lambda Printlambda.lambda
+      ++ Bytegen.compile_implementation modulename
+      ++ print_if ppf Clflags.dump_instr Printinstr.instrlist
+      ++ Emitcode.to_file oc modulename;
+      Warnings.check_fatal ();
+      close_out oc;
+      Pparse.remove_preprocessed inputfile;
+      Stypes.dump (Some (outputprefix ^ ".annot"));
+    with x ->
+      close_out oc;
+      remove_file objfile;
+      Pparse.remove_preprocessed inputfile;
+      Stypes.dump (Some (outputprefix ^ ".annot"));
+      raise x
+  end
+
+let c_file name =
+  Location.input_name := name;
+  if Ccomp.compile_file name <> 0 then exit 2
diff --git a/retype/test/class.ml b/retype/test/class.ml
new file mode 100644
index 0000000..6d99bb1
--- /dev/null
+++ b/retype/test/class.ml
@@ -0,0 +1,15 @@
+class c = object
+end
+
+(*
+class c = object (_ as selfpat-* as selfpat-1)  end
+*)
+
+class c1 = object (_)
+end
+
+class c2 = object (self)
+end
+
+class c3 = object (self as self')
+end
diff --git a/retype/test/class_method.ml b/retype/test/class_method.ml
new file mode 100644
index 0000000..d17701c
--- /dev/null
+++ b/retype/test/class_method.ml
@@ -0,0 +1,20 @@
+class c = object
+  method m = 1
+end
+
+(*
+class c =
+  Fatal error: exception Assert_failure("parsing/pprintast.ml", 629, 8)
+Raised at file "parsing/pprintast.ml", line 629, characters 8-20
+*)
+
+class c1 = object
+  val v = 1
+end
+
+class c2 = object
+  val v = 1
+  method m1 = v
+  method m2 = v
+end
+
diff --git a/retype/test/unused.ml b/retype/test/unused.ml
new file mode 100644
index 0000000..356bb0f
--- /dev/null
+++ b/retype/test/unused.ml
@@ -0,0 +1,3 @@
+let f x = ()
+let g (x:int) = x
+let h (x:int) = ()
diff --git a/retype/untypeast.ml b/retype/untypeast.ml
new file mode 100644
index 0000000..d83d117
--- /dev/null
+++ b/retype/untypeast.ml
@@ -0,0 +1,579 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                OCaml                                   *)
+(*                                                                        *)
+(*    Thomas Gazagnaire (OCamlPro), Fabrice Le Fessant (INRIA Saclay)     *)
+(*                                                                        *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et     *)
+(*   en Automatique.  All rights reserved.  This file is distributed      *)
+(*   under the terms of the Q Public License version 1.0.                 *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes
+open Typedtree
+open Parsetree
+
+let string_is_prefix ?(from=0) sub str =
+  let sublen = String.length sub in
+  try 
+    String.sub str from sublen = sub
+  with _ -> false
+
+(*
+Some notes:
+
+   * For Pexp_function, we cannot go back to the exact original version
+   when there is a default argument, because the default argument is
+   translated in the typer. The code, if printed, will not be parsable because
+   new generated identifiers are not correct.
+
+   * For Pexp_apply, it is unclear whether arguments are reordered, especially
+    when there are optional arguments.
+
+  * TODO: check Ttype_variant -> Ptype_variant (stub None)
+
+*)
+
+
+let rec lident_of_path path =
+  match path with
+      Path.Pident id -> Longident.Lident (Ident.name id)
+    | Path.Pdot (p, s, _) -> Longident.Ldot (lident_of_path p, s)
+    | Path.Papply (p1, p2) ->
+        Longident.Lapply (lident_of_path p1, lident_of_path p2)
+
+let rec untype_structure str =
+  List.map untype_structure_item str.str_items
+
+and untype_structure_item item =
+  let desc =
+    match item.str_desc with
+      Tstr_eval exp -> Pstr_eval (untype_expression exp)
+    | Tstr_value (rec_flag, list) ->
+        Pstr_value (rec_flag, List.map (fun (pat, exp) ->
+              untype_pattern pat, untype_expression exp) list)
+    | Tstr_primitive (_id, name, v) ->
+        Pstr_primitive (name, untype_value_description v)
+    | Tstr_type list ->
+        Pstr_type (List.map (fun (_id, name, decl) ->
+              name, untype_type_declaration decl) list)
+    | Tstr_exception (_id, name, decl) ->
+        Pstr_exception (name, untype_exception_declaration decl)
+    | Tstr_exn_rebind (_id, name, _p, lid) ->
+        Pstr_exn_rebind (name, lid)
+    | Tstr_module (_id, name, mexpr) ->
+        Pstr_module (name, untype_module_expr mexpr)
+    | Tstr_recmodule list ->
+        Pstr_recmodule (List.map (fun (_id, name, mtype, mexpr) ->
+              name, untype_module_type mtype,
+              untype_module_expr mexpr) list)
+    | Tstr_modtype (_id, name, mtype) ->
+        Pstr_modtype (name, untype_module_type mtype)
+    | Tstr_open (ovf, _path, lid) -> Pstr_open (ovf, lid)
+    | Tstr_class list ->
+        Pstr_class (List.map (fun (ci, _, _) ->
+              { pci_virt = ci.ci_virt;
+                pci_params = ci.ci_params;
+                pci_name = ci.ci_id_name;
+                pci_expr = untype_class_expr ci.ci_expr;
+                pci_variance = ci.ci_variance;
+                pci_loc = ci.ci_loc;
+              }
+          ) list)
+    | Tstr_class_type list ->
+        Pstr_class_type (List.map (fun (_id, _name, ct) ->
+              {
+                pci_virt = ct.ci_virt;
+                pci_params = ct.ci_params;
+                pci_name = ct.ci_id_name;
+                pci_expr = untype_class_type ct.ci_expr;
+                pci_variance = ct.ci_variance;
+                pci_loc = ct.ci_loc;
+              }
+          ) list)
+    | Tstr_include (mexpr, _) ->
+        Pstr_include (untype_module_expr mexpr)
+  in
+  { pstr_desc = desc; pstr_loc = item.str_loc; }
+
+and untype_value_description v =
+  {
+    pval_prim = v.val_prim;
+    pval_type = untype_core_type v.val_desc;
+    pval_loc = v.val_loc }
+
+and untype_type_declaration decl =
+  {
+    ptype_params = decl.typ_params;
+    ptype_cstrs = List.map (fun (ct1, ct2, loc) ->
+        (untype_core_type ct1,
+          untype_core_type ct2, loc)
+    ) decl.typ_cstrs;
+    ptype_kind = (match decl.typ_kind with
+        Ttype_abstract -> Ptype_abstract
+      | Ttype_variant list ->
+          Ptype_variant (List.map (fun (_s, name, cts, loc) ->
+                (name, List.map untype_core_type cts, None, loc)
+            ) list)
+      | Ttype_record list ->
+          Ptype_record (List.map (fun (_s, name, mut, ct, loc) ->
+                (name, mut, untype_core_type ct, loc)
+            ) list)
+    );
+    ptype_private = decl.typ_private;
+    ptype_manifest = (match decl.typ_manifest with
+        None -> None
+      | Some ct -> Some (untype_core_type ct));
+    ptype_variance = decl.typ_variance;
+    ptype_loc = decl.typ_loc;
+  }
+
+and untype_exception_declaration decl =
+  List.map untype_core_type decl.exn_params
+
+and untype_pattern pat =
+  let desc =
+  match pat with
+      { pat_extra=[Tpat_unpack, _]; pat_desc = Tpat_var (_,name); _ } ->
+        Ppat_unpack name
+    | { pat_extra=[Tpat_type (_path, lid), _]; _ } -> Ppat_type lid
+    | { pat_extra= (Tpat_constraint ct, _) :: rem; _ } ->
+        Ppat_constraint (untype_pattern { pat with pat_extra=rem },
+                         untype_core_type ct)
+    | { pat_extra; pat_desc = Tpat_alias ( { pat_desc = Tpat_any }, id, name ) } when List.exists (function (Tpat_untypeast_mark, _) -> true | _ -> false) pat_extra ->
+        (* CR jfuruse: remove Tpat_untypeast_mark? *)
+        begin
+          match (Ident.name id).[0] with
+            'A'..'Z' ->
+              Ppat_unpack name
+          | _ ->
+              Ppat_var name
+        end
+    | _ ->
+    match pat.pat_desc with
+      Tpat_any -> Ppat_any
+    | Tpat_var (id, name) ->
+        begin
+          match (Ident.name id).[0] with
+            'A'..'Z' ->
+              Ppat_unpack name
+          | _ ->
+              Ppat_var name
+        end
+    | Tpat_alias (pat, _id, name) ->
+        Ppat_alias (untype_pattern pat, name)
+    | Tpat_constant cst -> Ppat_constant cst
+    | Tpat_tuple list ->
+        Ppat_tuple (List.map untype_pattern list)
+    | Tpat_construct (lid, _, args, explicit_arity) ->
+        Ppat_construct (lid,
+          (match args with
+              [] -> None
+            | [arg] -> Some (untype_pattern arg)
+            | args -> Some
+                  { ppat_desc = Ppat_tuple (List.map untype_pattern args);
+                  ppat_loc = pat.pat_loc; }
+          ), explicit_arity)
+    | Tpat_variant (label, pato, _) ->
+        Ppat_variant (label, match pato with
+            None -> None
+          | Some pat -> Some (untype_pattern pat))
+    | Tpat_record (list, closed) ->
+        Ppat_record (List.map (fun (lid, _, pat) ->
+              lid, untype_pattern pat) list, closed)
+    | Tpat_array list -> Ppat_array (List.map untype_pattern list)
+    | Tpat_or (p1, p2, _) -> Ppat_or (untype_pattern p1, untype_pattern p2)
+    | Tpat_lazy p -> Ppat_lazy (untype_pattern p)
+  in
+  {
+    ppat_desc = desc;
+    ppat_loc = pat.pat_loc;
+  }
+
+and option f x = match x with None -> None | Some e -> Some (f e)
+
+and untype_extra (extra, loc) sexp =
+  let desc =
+    match extra with
+      Texp_constraint (cty1, cty2) ->
+        Pexp_constraint (sexp,
+                         option untype_core_type cty1,
+                         option untype_core_type cty2)
+    | Texp_open (ovf, _path, lid, _) -> Pexp_open (ovf, lid, sexp)
+    | Texp_poly cto -> Pexp_poly (sexp, option untype_core_type cto)
+    | Texp_newtype s -> Pexp_newtype (s, sexp)
+  in
+  { pexp_desc = desc;
+    pexp_loc = loc }
+
+and untype_expression exp =
+  let desc =
+    match exp.exp_desc with
+      Texp_ident (_path, lid, _) -> Pexp_ident (lid)
+    | Texp_constant cst -> Pexp_constant cst
+    | Texp_let (rec_flag, list, exp) ->
+        Pexp_let (rec_flag,
+          List.map (fun (pat, exp) ->
+              untype_pattern pat, untype_expression exp) list,
+          untype_expression exp)
+    | Texp_function (label, cases, _) ->
+        Pexp_function (label, None,
+          List.map (fun (pat, exp) ->
+              (untype_pattern pat, untype_expression exp)) cases)
+    | Texp_apply (exp, list) ->
+        Pexp_apply (untype_expression exp,
+          List.fold_right (fun (label, expo, _) list ->
+              match expo with
+                None -> list
+              | Some exp -> (label, untype_expression exp) :: list
+          ) list [])
+    | Texp_match (exp, list, _) ->
+        Pexp_match (untype_expression exp,
+          List.map (fun (pat, exp) ->
+              untype_pattern pat, untype_expression exp) list)
+    | Texp_try (exp, list) ->
+        Pexp_try (untype_expression exp,
+          List.map (fun (pat, exp) ->
+              untype_pattern pat, untype_expression exp) list)
+    | Texp_tuple list ->
+        Pexp_tuple (List.map untype_expression list)
+    | Texp_construct (lid, _, args, explicit_arity) ->
+        Pexp_construct (lid,
+          (match args with
+              [] -> None
+          | [ arg ] -> Some (untype_expression arg)
+          | args -> Some
+            { pexp_desc = Pexp_tuple (List.map untype_expression args);
+              pexp_loc = exp.exp_loc; }
+          ), explicit_arity)
+    | Texp_variant (label, expo) ->
+        Pexp_variant (label, match expo with
+            None -> None
+          | Some exp -> Some (untype_expression exp))
+    | Texp_record (list, expo) ->
+        Pexp_record (List.map (fun (lid, _, exp) ->
+              lid, untype_expression exp
+          ) list,
+          match expo with
+            None -> None
+          | Some exp -> Some (untype_expression exp))
+    | Texp_field (exp, lid, _label) ->
+        Pexp_field (untype_expression exp, lid)
+    | Texp_setfield (exp1, lid, _label, exp2) ->
+        Pexp_setfield (untype_expression exp1, lid,
+          untype_expression exp2)
+    | Texp_array list ->
+        Pexp_array (List.map untype_expression list)
+    | Texp_ifthenelse (exp1, exp2, expo) ->
+        Pexp_ifthenelse (untype_expression exp1,
+          untype_expression exp2,
+          match expo with
+            None -> None
+          | Some exp -> Some (untype_expression exp))
+    | Texp_sequence (exp1, exp2) ->
+        Pexp_sequence (untype_expression exp1, untype_expression exp2)
+    | Texp_while (exp1, exp2) ->
+        Pexp_while (untype_expression exp1, untype_expression exp2)
+    | Texp_for (_id, name, exp1, exp2, dir, exp3) ->
+        Pexp_for (name,
+          untype_expression exp1, untype_expression exp2,
+          dir, untype_expression exp3)
+    | Texp_when (exp1, exp2) ->
+        Pexp_when (untype_expression exp1, untype_expression exp2)
+    | Texp_send (exp, meth, _) ->
+        Pexp_send (untype_expression exp, match meth with
+            Tmeth_name name -> name
+          | Tmeth_val id -> Ident.name id)
+    | Texp_new (_path, lid, _) -> Pexp_new (lid)
+    | Texp_instvar (_, path, name) ->
+      Pexp_ident ({name with txt = lident_of_path path})
+    | Texp_setinstvar (_, _path, lid, exp) ->
+        Pexp_setinstvar (lid, untype_expression exp)
+    | Texp_override (_, list) ->
+        Pexp_override (List.map (fun (_path, lid, exp) ->
+              lid, untype_expression exp
+          ) list)
+    | Texp_letmodule (_id, name, mexpr, exp) ->
+        Pexp_letmodule (name, untype_module_expr mexpr,
+          untype_expression exp)
+    | Texp_assert exp -> Pexp_assert (untype_expression exp)
+    | Texp_assertfalse -> Pexp_assertfalse
+    | Texp_lazy exp -> Pexp_lazy (untype_expression exp)
+    | Texp_object (cl, _) ->
+        Pexp_object (untype_class_structure cl)
+    | Texp_pack (mexpr) ->
+        Pexp_pack (untype_module_expr mexpr)
+  in
+  List.fold_right untype_extra exp.exp_extra
+    { pexp_loc = exp.exp_loc;
+      pexp_desc = desc }
+
+and untype_package_type pack =
+  (pack.pack_txt,
+    List.map (fun (s, ct) ->
+        (s, untype_core_type ct)) pack.pack_fields)
+
+and untype_signature sg =
+  List.map untype_signature_item sg.sig_items
+
+and untype_signature_item item =
+  let desc =
+    match item.sig_desc with
+      Tsig_value (_id, name, v) ->
+        Psig_value (name, untype_value_description v)
+    | Tsig_type list ->
+        Psig_type (List.map (fun (_id, name, decl) ->
+              name, untype_type_declaration decl
+          ) list)
+    | Tsig_exception (_id, name, decl) ->
+        Psig_exception (name, untype_exception_declaration decl)
+    | Tsig_module (_id, name, mtype) ->
+        Psig_module (name, untype_module_type mtype)
+    | Tsig_recmodule list ->
+        Psig_recmodule (List.map (fun (_id, name, mtype) ->
+              name, untype_module_type mtype) list)
+    | Tsig_modtype (_id, name, mdecl) ->
+        Psig_modtype (name, untype_modtype_declaration mdecl)
+    | Tsig_open (ovf, _path, lid) -> Psig_open (ovf, lid)
+    | Tsig_include (mty, _) -> Psig_include (untype_module_type mty)
+    | Tsig_class list ->
+        Psig_class (List.map untype_class_description list)
+    | Tsig_class_type list ->
+        Psig_class_type (List.map untype_class_type_declaration list)
+  in
+  { psig_desc = desc;
+    psig_loc = item.sig_loc;
+  }
+
+and untype_modtype_declaration mdecl =
+  match mdecl with
+    Tmodtype_abstract -> Pmodtype_abstract
+  | Tmodtype_manifest mtype -> Pmodtype_manifest (untype_module_type mtype)
+
+and untype_class_description cd =
+  {
+    pci_virt = cd.ci_virt;
+    pci_params = cd.ci_params;
+    pci_name = cd.ci_id_name;
+    pci_expr = untype_class_type cd.ci_expr;
+    pci_variance = cd.ci_variance;
+    pci_loc = cd.ci_loc;
+  }
+
+and untype_class_type_declaration cd =
+  {
+    pci_virt = cd.ci_virt;
+    pci_params = cd.ci_params;
+    pci_name = cd.ci_id_name;
+    pci_expr = untype_class_type cd.ci_expr;
+    pci_variance = cd.ci_variance;
+    pci_loc = cd.ci_loc;
+  }
+
+and untype_module_type mty =
+  let desc = match mty.mty_desc with
+      Tmty_ident (_path, lid) -> Pmty_ident (lid)
+    | Tmty_signature sg -> Pmty_signature (untype_signature sg)
+    | Tmty_functor (_id, name, mtype1, mtype2) ->
+        Pmty_functor (name, untype_module_type mtype1,
+          untype_module_type mtype2)
+    | Tmty_with (mtype, list) ->
+        Pmty_with (untype_module_type mtype,
+          List.map (fun (_path, lid, withc) ->
+              lid, untype_with_constraint withc
+          ) list)
+    | Tmty_typeof mexpr ->
+        Pmty_typeof (untype_module_expr mexpr)
+  in
+  {
+    pmty_desc = desc;
+    pmty_loc = mty.mty_loc;
+  }
+
+and untype_with_constraint cstr =
+  match cstr with
+    Twith_type decl -> Pwith_type (untype_type_declaration decl)
+  | Twith_module (_path, lid) -> Pwith_module (lid)
+  | Twith_typesubst decl -> Pwith_typesubst (untype_type_declaration decl)
+  | Twith_modsubst (_path, lid) -> Pwith_modsubst (lid)
+
+and untype_module_expr mexpr =
+  match mexpr.mod_desc with
+    Tmod_constraint (m, _, Tmodtype_implicit, _ ) ->
+      untype_module_expr m
+  | _ ->
+      let desc = match mexpr.mod_desc with
+          Tmod_ident (_p, lid) -> Pmod_ident (lid)
+        | Tmod_structure st -> Pmod_structure (untype_structure st)
+        | Tmod_functor (_id, name, mtype, mexpr) ->
+            Pmod_functor (name, untype_module_type mtype,
+              untype_module_expr mexpr)
+        | Tmod_apply (mexp1, mexp2, _) ->
+            Pmod_apply (untype_module_expr mexp1, untype_module_expr mexp2)
+        | Tmod_constraint (mexpr, _, Tmodtype_explicit mtype, _) ->
+            Pmod_constraint (untype_module_expr mexpr,
+              untype_module_type mtype)
+        | Tmod_constraint (_mexpr, _, Tmodtype_implicit, _) ->
+            assert false
+        | Tmod_unpack (exp, _pack) ->
+        Pmod_unpack (untype_expression exp)
+        (* TODO , untype_package_type pack) *)
+
+  in
+  {
+    pmod_desc = desc;
+    pmod_loc = mexpr.mod_loc;
+  }
+
+and untype_class_expr cexpr =
+  let desc = match cexpr.cl_desc with
+    | Tcl_constraint ( { cl_desc = Tcl_ident (_path, lid, tyl); _ },
+                       None, _, _, _ ) ->
+        Pcl_constr (lid,
+          List.map untype_core_type tyl)
+    | Tcl_structure clstr -> Pcl_structure (untype_class_structure clstr)
+
+    | Tcl_fun (label, pat, _pv, cl, _partial) ->
+        Pcl_fun (label, None, untype_pattern pat, untype_class_expr cl)
+
+    | Tcl_apply (cl, args) ->
+        Pcl_apply (untype_class_expr cl,
+          List.fold_right (fun (label, expo, _) list ->
+              match expo with
+                None -> list
+              | Some exp -> (label, untype_expression exp) :: list
+          ) args [])
+
+    | Tcl_let (rec_flat, bindings, _ivars, cl) ->
+        Pcl_let (rec_flat,
+          List.map (fun (pat, exp) ->
+              (untype_pattern pat, untype_expression exp)) bindings,
+          untype_class_expr cl)
+
+    | Tcl_constraint (cl, Some clty, _vals, _meths, _concrs) ->
+        Pcl_constraint (untype_class_expr cl,  untype_class_type clty)
+
+    | Tcl_ident _ -> assert false
+    | Tcl_constraint (_, None, _, _, _) -> assert false
+  in
+  { pcl_desc = desc;
+    pcl_loc = cexpr.cl_loc;
+  }
+
+and untype_class_type ct =
+  let desc = match ct.cltyp_desc with
+      Tcty_signature csg -> Pcty_signature (untype_class_signature csg)
+    | Tcty_constr (_path, lid, list) ->
+        Pcty_constr (lid, List.map untype_core_type list)
+    | Tcty_fun (label, ct, cl) ->
+        Pcty_fun (label, untype_core_type ct, untype_class_type cl)
+  in
+  { pcty_desc = desc;
+    pcty_loc = ct.cltyp_loc }
+
+and untype_class_signature cs =
+  {
+    pcsig_self = untype_core_type cs.csig_self;
+    pcsig_fields = List.map untype_class_type_field cs.csig_fields;
+    pcsig_loc = cs.csig_loc;
+  }
+
+and untype_class_type_field ctf =
+  let desc = match ctf.ctf_desc with
+      Tctf_inher ct -> Pctf_inher (untype_class_type ct)
+    | Tctf_val (s, mut, virt, ct) ->
+        Pctf_val (s, mut, virt, untype_core_type ct)
+    | Tctf_virt  (s, priv, ct) ->
+        Pctf_virt (s, priv, untype_core_type ct)
+    | Tctf_meth  (s, priv, ct) ->
+        Pctf_meth  (s, priv, untype_core_type ct)
+    | Tctf_cstr  (ct1, ct2) ->
+        Pctf_cstr (untype_core_type ct1, untype_core_type ct2)
+  in
+  {
+    pctf_desc = desc;
+    pctf_loc = ctf.ctf_loc;
+  }
+
+and untype_core_type ct =
+  let desc = match ct.ctyp_desc with
+      Ttyp_any -> Ptyp_any
+    | Ttyp_var s -> Ptyp_var s
+    | Ttyp_arrow (label, ct1, ct2) ->
+        Ptyp_arrow (label, untype_core_type ct1, untype_core_type ct2)
+  | Ttyp_tuple list -> Ptyp_tuple (List.map untype_core_type list)
+    | Ttyp_constr (_path, lid, list) ->
+        Ptyp_constr (lid,
+          List.map untype_core_type list)
+    | Ttyp_object list ->
+        Ptyp_object (List.map untype_core_field_type list)
+    | Ttyp_class (_path, lid, list, labels) ->
+        Ptyp_class (lid,
+          List.map untype_core_type list, labels)
+    | Ttyp_alias (ct, s) ->
+        Ptyp_alias (untype_core_type ct, s)
+    | Ttyp_variant (list, bool, labels) ->
+        Ptyp_variant (List.map untype_row_field list, bool, labels)
+    | Ttyp_poly (list, ct) -> Ptyp_poly (list, untype_core_type ct)
+    | Ttyp_package pack -> Ptyp_package (untype_package_type pack)
+  in
+  { ptyp_desc = desc; ptyp_loc = ct.ctyp_loc }
+
+and untype_core_field_type cft =
+  { pfield_desc = (match cft.field_desc with
+        Tcfield_var -> Pfield_var
+      | Tcfield (s, ct) -> Pfield (s, untype_core_type ct));
+    pfield_loc = cft.field_loc; }
+
+and untype_class_structure cs =
+  let rec remove_self_pcstr_pat = function
+    | { pat_desc = Tpat_alias (p, id, s) } when string_is_prefix "selfpat-" id.Ident.name ->
+        remove_self_pcstr_pat p
+    | p -> p
+  in
+  { pcstr_pat = untype_pattern (remove_self_pcstr_pat cs.cstr_pat);
+    pcstr_fields = List.map untype_class_field cs.cstr_fields;
+  }
+
+and untype_row_field rf =
+  match rf with
+    Ttag (label, bool, list) ->
+      Rtag (label, bool, List.map untype_core_type list)
+  | Tinherit ct -> Rinherit (untype_core_type ct)
+
+and untype_class_field cf =
+  let desc = match cf.cf_desc with
+      Tcf_inher (ovf, cl, super, _vals, _meths) ->
+        Pcf_inher (ovf, untype_class_expr cl, super)
+    | Tcf_constr (cty, cty') ->
+        Pcf_constr (untype_core_type cty, untype_core_type cty')
+    | Tcf_val (_lab, name, mut, _, Tcfk_virtual cty, _override) ->
+        Pcf_valvirt (name, mut, untype_core_type cty)
+    | Tcf_val (_lab, name, mut, _, Tcfk_concrete exp, override) ->
+        Pcf_val (name, mut,
+          (if override then Override else Fresh),
+          untype_expression exp)
+    | Tcf_meth (_lab, name, priv, Tcfk_virtual cty, _override) ->
+        Pcf_virt (name, priv, untype_core_type cty)
+    | Tcf_meth (_lab, name, priv, Tcfk_concrete exp, override) ->
+        Pcf_meth (name, priv,
+          (if override then Override else Fresh),
+          let is_self_pat = function
+            | { pat_desc = Tpat_alias(_pat, id, _) } ->
+                string_is_prefix "self-" (Ident.name id)
+            | _ -> false
+          in
+          let remove_self_poly_Pcf_meth = function
+            | { exp_desc = Texp_function("", [(pat, expr)], _) } when is_self_pat pat -> expr
+            | e -> e
+          in
+          let exp = remove_self_poly_Pcf_meth exp in
+          untype_expression exp)
+(*    | Tcf_let (rec_flag, bindings, _) ->
+        Pcf_let (rec_flag, List.map (fun (pat, exp) ->
+              untype_pattern pat, untype_expression exp) bindings)
+*)
+  | Tcf_init exp -> Pcf_init (untype_expression exp)
+  in
+  { pcf_desc = desc; pcf_loc = cf.cf_loc }
diff --git a/retype/untypeast.mli b/retype/untypeast.mli
new file mode 100644
index 0000000..d61fd4f
--- /dev/null
+++ b/retype/untypeast.mli
@@ -0,0 +1,17 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                OCaml                                   *)
+(*                                                                        *)
+(*      Thomas Gazagnaire (OCamlPro), Fabrice Le Fessant (INRIA Saclay)   *)
+(*                                                                        *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et     *)
+(*   en Automatique.  All rights reserved.  This file is distributed      *)
+(*   under the terms of the Q Public License version 1.0.                 *)
+(*                                                                        *)
+(**************************************************************************)
+
+val untype_structure : Typedtree.structure -> Parsetree.structure
+val untype_signature : Typedtree.signature -> Parsetree.signature
+val untype_expression : Typedtree.expression -> Parsetree.expression
+
+val lident_of_path : Path.t -> Longident.t
diff --git a/tools/untypeast.ml b/tools/untypeast.ml
index 6cbbc55..a070c88 100644
--- a/tools/untypeast.ml
+++ b/tools/untypeast.ml
@@ -14,6 +14,12 @@ open Asttypes
 open Typedtree
 open Parsetree
 
+let string_is_prefix ?(from=0) sub str =
+  let sublen = String.length sub in
+  try 
+    String.sub str from sublen = sub
+  with _ -> false
+
 (*
 Some notes:
 
@@ -135,6 +141,21 @@ and untype_pattern pat =
     | { pat_extra= (Tpat_constraint ct, _) :: rem; _ } ->
         Ppat_constraint (untype_pattern { pat with pat_extra=rem },
                          untype_core_type ct)
+    | { pat_extra; pat_desc = Tpat_alias ( { pat_desc = Tpat_any; pat_loc }, id, name ) } when pat_loc = Location.none ->
+        (* let (x : t) = ... x is unused ...
+           => let ((_ as x) : t) = ... x is unused ...
+
+           Since ocamlc gives different warnings for the former and the latter at stdlib/parsing.ml,
+           we need to recover the original.
+        *)
+        (* CR jfuruse: remove Tpat_untypeast_mark? *)
+        begin
+          match (Ident.name id).[0] with
+            'A'..'Z' ->
+              Ppat_unpack name
+          | _ ->
+              Ppat_var name
+        end
     | _ ->
     match pat.pat_desc with
       Tpat_any -> Ppat_any
@@ -202,6 +223,24 @@ and untype_expression exp =
           List.map (fun (pat, exp) ->
               untype_pattern pat, untype_expression exp) list,
           untype_expression exp)
+
+    | Texp_function 
+        (label, 
+         [ { pat_desc = Tpat_var (_, {txt = "*opt*"}) }, 
+           { exp_desc = 
+               Texp_let (Default, 
+                         [pat, { exp_desc = Texp_match(_, [_ (* Some *); (_, default) ], _) }], 
+                         exp)
+           } 
+         ],
+         _)
+        when Btype.is_optional label ->
+
+        let pat = untype_pattern pat in
+        let default = untype_expression default in
+        let exp = untype_expression exp in
+        Pexp_function(label, Some default, [pat, exp])
+
     | Texp_function (label, cases, _) ->
         Pexp_function (label, None,
           List.map (fun (pat, exp) ->
@@ -365,7 +404,7 @@ and untype_module_type mty =
           untype_module_type mtype2)
     | Tmty_with (mtype, list) ->
         Pmty_with (untype_module_type mtype,
-          List.map (fun (_path, lid, withc) ->
+          List.rev_map (fun (_path, lid, withc) -> (* rev to keep ordering *)
               lid, untype_with_constraint withc
           ) list)
     | Tmty_typeof mexpr ->
@@ -512,7 +551,12 @@ and untype_core_field_type cft =
     pfield_loc = cft.field_loc; }
 
 and untype_class_structure cs =
-  { pcstr_pat = untype_pattern cs.cstr_pat;
+  let rec remove_self_pcstr_pat = function
+    | { pat_desc = Tpat_alias (p, id, s) } when string_is_prefix "selfpat-" id.Ident.name ->
+        remove_self_pcstr_pat p
+    | p -> p
+  in
+  { pcstr_pat = untype_pattern (remove_self_pcstr_pat cs.cstr_pat);
     pcstr_fields = List.map untype_class_field cs.cstr_fields;
   }
 
@@ -522,6 +566,11 @@ and untype_row_field rf =
       Rtag (label, bool, List.map untype_core_type list)
   | Tinherit ct -> Rinherit (untype_core_type ct)
 
+and is_self_pat = function
+  | { pat_desc = Tpat_alias(_pat, id, _) } ->
+      string_is_prefix "self-" (Ident.name id)
+  | _ -> false
+
 and untype_class_field cf =
   let desc = match cf.cf_desc with
       Tcf_inher (ovf, cl, super, _vals, _meths) ->
@@ -539,11 +588,21 @@ and untype_class_field cf =
     | Tcf_meth (_lab, name, priv, Tcfk_concrete exp, override) ->
         Pcf_meth (name, priv,
           (if override then Override else Fresh),
+          let remove_fun_self_Pcf_meth = function
+            | { exp_desc = Texp_function("", [(pat, expr)], _) } when is_self_pat pat -> expr
+            | e -> e
+          in
+          let exp = remove_fun_self_Pcf_meth exp in
           untype_expression exp)
 (*    | Tcf_let (rec_flag, bindings, _) ->
         Pcf_let (rec_flag, List.map (fun (pat, exp) ->
               untype_pattern pat, untype_expression exp) bindings)
 *)
-  | Tcf_init exp -> Pcf_init (untype_expression exp)
+  | Tcf_init exp -> 
+      let remove_fun_self_Tcf_init = function
+        | { exp_desc = Texp_function("", [(pat, expr)], _) } when is_self_pat pat -> expr
+        | e -> e
+      in
+      Pcf_init (untype_expression (remove_fun_self_Tcf_init exp))
   in
   { pcf_desc = desc; pcf_loc = cf.cf_loc }
diff --git a/typing/typeclass.ml b/typing/typeclass.ml
index db5bbde..b3bdbde 100644
--- a/typing/typeclass.ml
+++ b/typing/typeclass.ml
@@ -431,7 +431,7 @@ and class_signature env sty sign loc =
   end;
 
   (* Class type fields *)
-  let (fields, val_sig, concr_meths, inher) =
+  let (rev_fields, val_sig, concr_meths, inher) =
     List.fold_left (class_type_field env self_type meths)
       ([], Vars.empty, Concr.empty, [])
       sign
@@ -442,7 +442,7 @@ and class_signature env sty sign loc =
    cty_inher = inher}
   in
   { csig_self = self_cty;
-    csig_fields = fields;
+    csig_fields = List.rev rev_fields;
     csig_type = cty;
     csig_loc = loc;
     }
diff --git a/typing/typecore.ml b/typing/typecore.ml
index 2964f3f..2846110 100644
--- a/typing/typecore.ml
+++ b/typing/typecore.ml
@@ -1107,8 +1107,15 @@ let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
       if separate then
         match p.pat_desc with
           Tpat_var (id,s) ->
+            (* Hack rather than fix:
+               Changing [(x : t)] to [((_ : as x) : t)] changes the warning if x is not used,
+               and this is problematic at retyping stdlib/parsing.ml. We put a special mark
+               [Location.none] to the inserted [Tpat_any] so that untypeast can recover 
+               the original expression.
+            *)
             {p with pat_type = ty;
-             pat_desc = Tpat_alias ({p with pat_desc = Tpat_any}, id,s);
+             pat_desc = Tpat_alias ({p with pat_desc = Tpat_any;
+                                            pat_loc = Location.none }, id, s);
              pat_extra = [Tpat_constraint cty, loc];
             }
         | _ -> {p with pat_type = ty;
diff --git a/typing/typemod.ml b/typing/typemod.ml
index 7cbda25..802c79e 100644
--- a/typing/typemod.ml
+++ b/typing/typemod.ml
@@ -170,20 +170,20 @@ let merge_constraint initial_env loc  sg lid constr =
         real_id := Some id;
         (Pident id, lid, Twith_typesubst tdecl),
         make_next_first rs rem
-    | (Sig_module(id, mty, rs) :: rem, [s], Pwith_module (lid))
+    | (Sig_module(id, mty, rs) :: rem, [s], Pwith_module (lid'))
       when Ident.name id = s ->
-        let (path, mty') = Typetexp.find_module initial_env loc lid.txt in
+        let (path, mty') = Typetexp.find_module initial_env loc lid'.txt in
         let newmty = Mtype.strengthen env mty' path in
         ignore(Includemod.modtypes env newmty mty);
-        (Pident id, lid, Twith_module (path, lid)),
+        (Pident id, lid, Twith_module (path, lid')),
         Sig_module(id, newmty, rs) :: rem
-    | (Sig_module(id, mty, rs) :: rem, [s], Pwith_modsubst (lid))
+    | (Sig_module(id, mty, rs) :: rem, [s], Pwith_modsubst (lid'))
       when Ident.name id = s ->
-        let (path, mty') = Typetexp.find_module initial_env loc lid.txt in
+        let (path, mty') = Typetexp.find_module initial_env loc lid'.txt in
         let newmty = Mtype.strengthen env mty' path in
         ignore(Includemod.modtypes env newmty mty);
         real_id := Some id;
-        (Pident id, lid, Twith_modsubst (path, lid)),
+        (Pident id, lid, Twith_modsubst (path, lid')),
         make_next_first rs rem
     | (Sig_module(id, mty, rs) :: rem, s :: namelist, _)
       when Ident.name id = s ->
@@ -440,7 +440,7 @@ let rec transl_modtype env smty =
   | Pmty_with(sbody, constraints) ->
       let body = transl_modtype env sbody in
       let init_sg = extract_sig env sbody.pmty_loc body.mty_type in
-      let (tcstrs, final_sg) =
+      let (rev_tcstrs, final_sg) =
         List.fold_left
           (fun (tcstrs,sg) (lid, sdecl) ->
             let (tcstr, sg) = merge_constraint env smty.pmty_loc sg lid sdecl
@@ -448,7 +448,7 @@ let rec transl_modtype env smty =
             (tcstr :: tcstrs, sg)
         )
         ([],init_sg) constraints in
-      mkmty (Tmty_with ( body, tcstrs))
+      mkmty (Tmty_with ( body, List.rev rev_tcstrs))
       (Mtype.freshen (Mty_signature final_sg)) env loc
   | Pmty_typeof smod ->
       let tmty, mty = !type_module_type_of_fwd env smod in
