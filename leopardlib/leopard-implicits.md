The type for implicits

`('a, 'resolution) Leopard.Implicit.t`

# Resolution DSL

The definition of the resolution DSL is given by the following BNF:

```
  <t> ::= <traversal>
        | aggressive <t>

  <traversal> ::= <search_space>
                | filter <filter> <traversal>

  <search_space> ::= <module_specifier>
                   | deep <search_space>
                   | (<search_space>, .. , <search_space>) 

  <module_specifier> ::= <path>
                      | just <path>
                      | (related : <tvar>)
                      | open_imp

  <filter> ::= substr <string>
             | or <filter> .. <filter>
             | and_ <filter> .. <filter>
             | not <filter>

  <path> : module path, such as Print, Num, etc.
  <tvar> : type variable
```

## Module path `M`

The resolution candidates are the values defined in the modules accessible by module path `M` and `P.M` in the scope of the resolution, where `P` is an opened module path in the context.  If there are no such modules in the scope, no candidates are taken.

## `just M`

The resolution candidates are the values defined in the module accessible by `M` in the scope of the resolution.  If there is no such module in the scope, no candidates are taken.

## `(related : 'a)`

`(related : 'a)` takes one of the type variables of the first type argument of the implicit type.  When the type variable is instantiated to a data type defined in module `M` such as `int M.t`, the resolution candidates are the values defined in `M`.  If the type variable is instantiated not to a data type, no candidates are taken.

## `open_imp`

`open_imp` takes the values defined in the modules `M` opened specially 
by `open [@imp] M`. 

## `deep s`

`deep s` extends the candidates to those defined in the sub-modules of the modules which are specified by `s`.

## `(s, .., s)`

Union of search spaces.

## `filter f t`

`filter f t` filters candidates of `t` using the filter predicate `f`.

## `substr <string>`

Filter by name of candidates.  It only chooses candidates whose path names
contain the given string.

## `or f .. f`

Logical or combinator of filter predicates.

## `and_ f .. f`

Logical and combinator of filter predicates. `and_`, not `and`.

## `not f`

Logical not combinator of filter predicates.

## `aggressive t`

Make the sub-constraint extraction more aggressive.

By default, a sub-constraint of a candidate must have the form of
`?_label: (_,_) Leopard.Implicits.t -> ..`, an optional argument with
a label starts with `_` with type `(_,_) Leopard.Implicits.t`.

With `aggresive t`, any function argument with generalized type variables
is considered as a candidate: it is handled as if it had a type
`(ty,[%imp aggressive t]) Leopard.Implicits.t` where `ty` is the type of
the argument.

This `aggressive t` is useful to make functions generated by ppx_deriving
overloaded with the conjunction with `(related : 'a)`.
