
#     type _ t = Int : int t
#   val to_int : 'a t -> 'a -> int = <fun>
#   val w_bool : bool t = Int
# Characters 34-37:
  let f_bool (x : bool) : int = let Int = w_bool in x;; (* fail *)
                                    ^^^
Error: This pattern matches values of type int t
       but a pattern was expected which matches values of type bool t
       Type int is not compatible with type bool 
#   val w_buffer : Buffer.t t = Int
# val f_buffer : Buffer.t -> int = <fun>
#   val w_spec : Arg.spec t = Int
# Characters 38-41:
  let f_spec (x : Arg.spec) : int = let Int = w_spec in x;; (* ok *)
                                        ^^^
Error: This pattern matches values of type int t
       but a pattern was expected which matches values of type Arg.spec t
       Type int is not compatible with type Arg.spec 
#     module M : sig type u val w : u t val x : u end
# val m_x : int = 33
#   module F :
  functor (X : sig type u = int val x : u end) -> sig val x : int end
# val fm_x : int = 33
#   module M' : sig module M : sig type u val w : u t val x : u end end
#   module F' :
  functor (X : sig module M : sig type u = int val x : u end end) ->
    sig val x : int end
#   val fm'_x : int = 33
#                           type (_, _) eq = Refl : ('a, 'a) eq
module type S = sig type t val eql : (t, int) eq end
module F : functor (M : S) -> sig val zero : M.t end
# 
